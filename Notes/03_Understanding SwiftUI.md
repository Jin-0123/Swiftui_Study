# Chapter 3: Understanding SwiftU

## Why SwiftUI?
인터페이스 빌더와 스토리보드는 개발을 빠르게 할 수 있도록 많은 도움을 주지만 일부 많은 개발자들은 코드로 뷰르 만드는 것을 더 선호함. </br>
코드로 작성했을 때, UI의 재사용과 편집에 더 효율적이기 때문. </br>
IBOutlet, IBAction의 이름이 바뀌거나 제거 되었을 때 인터페이스 빌더에서는 코드르 보지 못하기 때문에 크래시가 남. </br>
세그나 테이블뷰의 identifier의 스트링 오타때문에 짜증이 난 적이 있을 것이다. 엑스코드는 그것을 체크해 줄 수 없다. </br>

SwiftUI는 코드와 바로 옆에 프리뷰를 보면서 작업가능. </br>
변화가 생겼을 때 바로 업데이트를 해줌. 어떤 identifier 스트링이 잘못되는 경우도 없음. </br>
코드량도 작성한 것보다 훨씬 더 코드가 적고, 이해햐기 쉽다. </br>


SwiftUI는 UIKit을 대체하는 것이 아니라 Swift와 ObjectiveC와 같이 둘다 사용가능하다. </br>
또한 SwiftUI API는 어떤 플랫폼이든 일관적이어서, 멀티 플랫폼을 구현하기 쉽다. </br>

### Declarative app development
SwiftUI는 너가 **declarative** 앱 개발이 가능하도록 한다. </br>
다르게 생각하기를 익힌다면 더 빠르게 좋은 앱을 개발할 수 있을 것이다. </br>
Declartive앱 개발의 의미는 너가 원하는 뷰는 어떻게 생겼고, 그들이 의존하는 데이터는 어떤 것인지 선언하는 것을 말한다. </br>
SwiftUI 프레임워크는 그들이 의존하고 있는 데이터가 변경됨에 따라 뷰를 나타내고 업데이트 해야할 때 뷰를 만든다. </br>

너는 뷰의 상태가 어떻게 노출되는지, 뷰의 데이터 의존상태에서 SWiftUI가 어떻게 리액트 해야하는지를 선언한다. </br>

- Views
코드와 동기화되는 Declartive UI. </br>
다른 플랫폼에도 API가 일관적이어서 한번 배우면 어디든지 적용할 수 있다. </br>
Controls는 그들의 역할을 서술한다. 그들의 외형이아니라. 그래서 같은 컨트롤이 해당 플랫폼에 따라 적절하게 보이도록 한다. </br>

- Data
Declretice 데이터 의존성은 데이터가 변화할 때 뷰르 업데이트한다. </br>
뷰의 가능한 상태르 선언하고 각 상태에 따라 뷰가 어떻게 변하는지 선언한다. </br>

- Navigation
조건적인 서브뷰를 네비게이션과 대체할 수 있음

- Integration
SwiftUI와 UIKit의 통합

## Getting started
### SWiftUI vs. UIKit
UIKit 앱으로 만들기 위해서는 스토리 보드에 몇몇의 라벨과 버튼, 세개의 슬라이드가 있고 outlet과 action으로 뷰 컨트롤러와 연결되어있다. 그 다음 메서드를 작성해 슬라이드가 움직일 때마다 값을 색, 라벨, 라벨의 컬러르 변경한다. 어떤 것을 할지 정확하 순서로 생각해야한단다. 이 단계는 쉽게 잊게 된다. </br>

SwiftUI로 만들기 위해서는 Color, Text, Button, Slider 서브뷰르 나타나기 원하는 순서대로 목록화한다. (오토레이아웃 셋탕하는 것보다 훨씬 쉬움) </br>
그 다음 각각 데이터에 따라 어떻게 변화하는지 선언한다. </br>
뷰의 상태에 따라서 뷰가 일관성을 유지하 수 있도록 데이터 의존관계를 관리한다. </br>

올바른 순서가 무엇인지 걱정할 필요 없고 UI 객체 업데이트를 잊을 걱정하 필요도 없다. 캔버스 프리뷰는 스토리보드가 필요없다는 것을 의미한다. </br>
서브뷰는 스스로 업데이트가 유지되며 뷰 컨트롤러 또한 그렇다. 그리고 라이브 프리뷰는 너가 거의 시뮬레이터를 실행하지 않아도 된다는 것을 뜻한다. </br>

## Declaring views



### Environment values
